#include "cppdefs.h"
#ifdef MPI
# define BEGIN_MPI_MASTER if (mynode==0) then
# define END_MPI_MASTER endif
#else
# define BEGIN_MPI_MASTER
# define END_MPI_MASTER
#endif
                                        ! Read and report model input
      subroutine read_inp(ierr)         ! parameters from keyword-based
      implicit none                     ! startup file.
      integer ierr
#include "param.h"
#include "scoord.h"
#include "scalars.h"
#include "ncvars.h"
#if defined WRITE_TEMP_REST || defined WRITE_SALT_REST || defined WRITE_HEATFLX || defined WRITE_CO2FLX
# include "forces.h"
#endif
#include "boundary.h"
#ifndef NONLIN_EOS
# include "eos_vars.h"
#endif
#ifdef FLOATS
# include "ncvars_floats.h"
#endif
#ifdef BGC_FLUX_ANALYSIS
# include "bgcflux.h"
# include "ncroms_bgcflux.h"
#endif
#ifdef PHYS_FLUX_ANALYSIS
# include "physflux.h"
# include "ncroms_physflux.h"
#endif
#ifdef MPI
# include "mpif.h"
#endif
      integer, parameter :: input=15, testunit=40,
     &                  max_fname=256, max_kwsize=32
      character(len=max_fname)  :: fname
      character(len=max_kwsize) :: keyword
      character(len=3), parameter :: end_signal='end'
      integer is,ie,  kwlen, lstr, lenstr
     &        , nbasic, naux
#ifdef SOLVE3D
     &        , itrc
#endif
#if (defined BIOLOGY_BEC || defined BIOLOGY_BEC2 || defined BIOLOGY_NPZDOC)\
    && defined VARIABLE_ANN_ATM_PCO2
      logical futr_scen_valid
#endif
#ifdef INT_IARGC
      integer iargc
#endif

! Check CPP-switches for consistency. This operation is split into
! multiple stages because the first subroutine, "check_switches1", is
! generated by special program cppcheck (file cppcheck.F) by examining
! and documention all CPP-switches appearing in "cppdefs.h" regardless
! of their context, and automatically generate a code to keep track of
! their status, as well as to traps multiply defined global
! configurations (project switches, such as PACIFIC, USWEST, DAMEE_B,
! etc).  The subsequent routines are to track locally-defined switches
! in few other places throughout the code (these routines are
! hand-written), and, finally, the last routine, "check_switches2"
! contains traps for mutually exclussive definitions of non-project
! switches (e.g. it traps multiply defined vertical mixing schemes or
! lateral boundary conditions; this code is also hand written).
! All the checking routines codes are written in transparent mode:
! they assumed that error flag (ierr) is initialized at the entry and
! they add 1 for each error discovered.

      ierr=0                      ! <-- reset error counter
      call check_tiling(ierr)
      call check_switches1(ierr)
#ifdef SOLVE3D
      call check_scoord_switches(ierr)
      call check_pre_step_switches(ierr)
      call check_step_uv1_switches(ierr)
      call check_step_uv2_switches(ierr)
      call check_step_t_switches(ierr)
      call check_set_HUV1_switches(ierr)
# ifdef LMD_KPP
      call check_kpp_switches(ierr)
# endif
      call check_switches2(ierr)
#endif
      if (ierr /= 0) return
      mpi_master_only call print_switches

! Use pre-set default startup filename for known applications, or
! get it as an argument from command line via iargc-getarg (override
! default). NOTE: The usage of the executable should be either
!
!              roms
!        or
!              roms startup_file_name
!
! WITHOUT the UNIX redirection (<): roms < startup_file like it
! used to be.

#if defined SOLITON
      fname='roms.in.Soliton'
#elif defined SEAMOUNT
      fname='roms.in.Seamount'
#elif defined WAVE_RAD
      fname='roms.in.WaveRad'
#elif defined ISWAKE
      fname='roms.in.IsWake'
#elif defined UPWELLING
      fname='roms.in.Upwelling'
#elif defined GRAV_ADJ
      fname='roms.in.GravAdj'
#elif defined IBERIA
      fname='roms.in.Iberia'
#elif defined RIVER
      fname='roms.in.River'
#elif defined PACIFIC
      fname='pacific.in'
#elif defined ONE_DIM
      fname='one_dim.in'
#elif defined PACIFIC_2D
      fname='pacific_2D.in'
#elif defined CANBAS2
c--      fname='canBas2.in'
c--      fname='cblanco.in'
      fname='unpr.in'
#elif defined SPIRAL
      fname='spiral.in'
#elif defined PACBIG
      fname='pacbig.in'
#elif defined NWPAC
      fname='nwp.in'
#elif defined SMSC
      fname='smsc.in'
#elif defined SMSC_SUB
      fname='smsc_sub.in'
#elif defined USWEST
      fname='mb_l1_safe.in'
c--      fname='roms.in.USW20'
c--      fname='roms.in.US_West'
#elif defined SCB_TEST
      fname='scb_test.in'
#elif defined USWC_CENTRAL
      fname='usw.in'
#elif defined HBCS60
      fname='hbcs.in'
#elif defined HBCS5
      fname='hbcs5.in'
#elif defined SAWC
      fname='sawc.in'
#elif defined DAMEE_B
      fname='roms.in.Atl4'
#else
      fname='roms.in'  !<-- default
#endif
#ifdef MPI
      if (mynode == 0) then
#endif
        is=iargc() ; if (is == 1) call getarg(is,fname)
#ifdef MPI
      endif
      call MPI_Bcast(fname,64,MPI_BYTE, 0, ocean_grid_comm, ierr)
#endif

      wrthis(indxTime)=.false.
#ifdef AVERAGES
      wrtavg(indxTime)=.false.
#endif
#ifdef STATIONS
      wrtsta(indxTime)=.true.
#endif

! Read in keyword name: keep trying, until keyword is found.
!----- -- ------- ----- ---- ------- ------ ------- ---------

      call setup_kwds(ierr)
      open(input, file=fname, status='old', form='formatted', err=97)
   1   keyword='                                '
       read(input,'(A)',err=1,end=99) keyword
       if (keyword(1:1) == '!') goto 1
       is=1
   2   if (is == max_kwsize) then
         goto 1
       elseif (keyword(is:is) == ' ') then
         is=is+1
         goto 2
       endif
       ie=is
   3   if (keyword(ie:ie) == ':') then
         keyword(ie:ie)=' '
         goto 4           !--> recognized keyword.
       elseif (keyword(ie:ie) /= ' ' .and. ie < max_kwsize) then
         ie=ie+1
         goto 3
       endif
       goto 1
   4   kwlen=ie-is
       if (is > 1) keyword(1:kwlen)=keyword(is:is+kwlen-1)

! Read input parameters according to the keyword:
!----- ----- ---------- --------- --- ---- -------

! Title

        if (keyword(1:kwlen) == 'title') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) title
          lstr=lenstr(title)
          mpi_master_only write(*,'(/1x,A)') title(1:lstr)

! Time-stepping parameters

        elseif (keyword(1:kwlen) == 'time_stepping') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) ntimes, dt, ndtfast, ninfo
          mpi_master_only write(*,
     &  '(5x,A,I10,3x,A/9x,A,F11.4,2x,A/4x,A,I10,3x,A/6x,A,I10,3x,2A)'
     &    ) 'ntimes =',  ntimes, 'total number of 3D timesteps',
     &          'dt =',     dt,  'time step [sec] for 3D equations',
     &     'ndtfast =', ndtfast, 'mode-splitting ratio',
     &       'ninfo =',   ninfo, 'number of steps between runtime ',
     &                                              'diagnostics'

          dtfast=dt/dble(ndtfast)     ! set barotropic time step.
#ifndef SOLVE3D
          dt=dtfast
          ntimes=ntimes*ndtfast
          ninfo=ninfo*ndtfast
#endif

! Vertical S-coordinates transformation. Note that "hc" may be chosen
! to be very large (infinity) if vertically uniform sigma is desired.

#ifdef SOLVE3D
        elseif (keyword(1:kwlen) == 'S-coord') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) theta_s, theta_b, hc
          mpi_master_only write(*,'(2(/4x,A,F10.7,2x,A))')
     &    'theta_s =', theta_s, 'vertical S-coordinate surface',
     &    'theta_b =', theta_b, 'and bottom stretching parameters'
          if (hc < 1000.) then
            mpi_master_only write(*,'(9x,A,F10.5,2x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          else
            mpi_master_only write(*,'(9x,A,ES14.5,2x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          endif

!--> Boussinesq  reference density.

        elseif (keyword(1:kwlen) == 'rho0') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) rho0
          mpi_master_only write(*,'(7x,A,F10.4,2x,A)')  'rho0 =',
     &            rho0, 'Boussinesq reference density [kg/m^3].'

# ifndef NONLIN_EOS
!--> Parameters for linear equations of state.

        elseif (keyword(1:kwlen) == 'lin_rho_eos') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) Tcoef, T0
#  ifdef SALINITY
     &                       , Scoef, S0
#  endif
          mpi_master_only write(*,'(4(6x,A,F10.4,2x,A/))')
     &      'Tcoef =', Tcoef,  'thermal expansion [kg/m^3/deg C]'
     &    , '   T0 =',    T0,  'reference temperature [deg C]'
#  ifdef SALINITY
     &    , 'Scoef =', Scoef,  'saline contraction [kg/m^3/PSU]'
     &    , '   S0 =',    S0,  'reference salinity [PSU]'
#  endif
# endif
#endif /* SOLVE3D */


#ifdef UV_VIS2
! Lateral viscosity coefficients.

        elseif (keyword(1:kwlen) == 'lateral_visc') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) visc2
          mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')   'visc2 =',
     &    visc2, 'horizontal Laplacian kinematic viscosity [m^2/s]'


# if !defined EW_PERIODIC || !defined NS_PERIODIC
! Lateral boundary slipperness.

        elseif (keyword(1:kwlen) == 'gamma2') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) gamma2
          mpi_master_only write(*,'(5x,A,ES10.3,2x,2A)') 'gamma2 =',
     &                           gamma2, 'slipperiness parameter: ', 
     &                           'free-slip = +1, or no-slip = -1.'
# endif
#endif
#ifdef SOLVE3D
# ifdef TS_DIF2
! Horizontal Laplacian mixing coefficients for tracers.

        elseif (keyword(1:kwlen) == 'tracer_diff2') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) (tnu2(itrc),itrc=1,NT)
          do itrc=1,NT
            if (itrc == itemp) then
              mpi_master_only write(*,'(3x,A,I2,A,ES10.3,2x,2A,I2,A)')
     &         'tnu2(',itrc,') =',tnu2(itrc),'horizontal Laplacian ',
     &         'kinematic heat conductivity [m^2/s]'
            else
              mpi_master_only write(*,'(3x,A,I2,A,ES10.3,2x,2A,I2,A)')
     &         'tnu2(',itrc,') =',tnu2(itrc),'horizontal Laplacian ',
     &         'diffusion for tracer ', itrc, ', [m^2/s]'
            endif
          enddo
# endif
#endif

! Bottom drag coefficients.

        elseif (keyword(1:kwlen) == 'bottom_drag') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) rdrg, rdrg2
#ifdef SOLVE3D
     &                             , Zob
#endif
          mpi_master_only write(*,'(7x,A,ES10.3,2x,A)')
     &     'rdrg =', rdrg,  'linear bottom drag coefficient [m/s]'
          mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &    'rdrg2 =', rdrg2, 'quadratic bottom drag coefficient, nondim'
#ifdef SOLVE3D
          mpi_master_only write(*,'(8x,A,ES10.3,2x,A)')
     &  ,   'Zob =', Zob,   'bottom roughness height [m]'
#endif

#ifdef SOLVE3D
# if !defined LMD_MIXING && !defined BVF_MIXING && !defined PP_MIXING\
                         && !defined MY2_MIXING && !defined MY25_MIXING

! Background vertical viscosity and mixing coefficients for tracers.

        elseif (keyword(1:kwlen) == 'vertical_mixing') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) Akv_bak,(Akt_bak(itrc),itrc=1,NT)
          mpi_master_only write(*,'(4x,A,ES10.3,2x,A)')  'Akv_bak =',
     &               Akv_bak, 'background vertical viscosity [m^2/s]'
          do itrc=1,NT
            mpi_master_only write(*,'(1x,A,I1,A,ES10.3,2x,2A)')
     &                     'Akt_bak(',  itrc,  ') =',  Akt_bak(itrc),
     &                     'background vertical mixing [m^2/s] for ',
     &        vname(2,indxT+itrc-1)(1:lenstr(vname(2,indxT+itrc-1)))
          enddo
# endif
# ifdef MY25_MIXING
! Mellor-Yamada Level 2.5 turbulent closure parameters.

        elseif (keyword(1:kwlen) == 'MY_bak_mixing') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) Akq_bak, q2nu2, q2nu4
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')  'Akq_bak =',
     &        Akq_bak, 'Background vertical mixing for TKE, [m^2/s]'
#  ifdef Q_DIF2
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')    'q2nu2 =',
     &         q2nu2, 'Horizontal Laplacian mixing for TKE, [m^2/s]'
#  endif
#  ifdef Q_DIF4
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')    'q2nu4 =',
     &        q2nu4, 'Horizontal biharmonic mixing for TKE, [m^4/s]'
#  endif
# endif

!# if defined SFLX_CORR && defined SALINITY
!
!        elseif (keyword(1:kwlen) == 'SSS_correction') then
!          call cancel_kwd(keyword(1:kwlen), ierr)
!          read(input,*,err=95) dSSSdt
!          mpi_master_only write(*,'(5x,A,ES10.3,2x,2A/38x,A)')
!     &   'dSSSdt =', dSSSdt, 'Sea-Surface Salinity correction ',
!     &                       'coefficient expressed',
!     &            'kinematically as "piston velocity" [cm/day]' 
!
!          dSSSdt=dSSSdt/(100.D0*day2sec)   !<-- convert to [m/s]
!           
!# endif
#endif /* SOLVE3D */



#if  defined T_FRC_BRY || defined M2_FRC_BRY || defined TNUDGING \
  || defined Z_FRC_BRY || defined M3_FRC_BRY || defined M2NUDGING \
                       || defined M3NUDGING  || defined WKB_FRC_BRY

        elseif (keyword(1:kwlen) == 'ubind') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) ubind
            mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &     'ubind =', ubind, 'open boundary binding velcity [m/s]'


/* OBSOLETE --->
! Parameters for OBC nudging and nudging layers;
! converted from [days] to [sec^-1]


c-->    elseif (keyword(1:kwlen) == 'nudg_cof') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) tauM2_in, tauM2_out, attnM2
# ifdef SOLVE3D
     &                       , tauM3_in, tauM3_out
     &                       , tauT_in,  tauT_out
# endif
          if (tauM2_in > 0.) then                ! convert relaxation
            tauM2_in =1./(tauM2_in *day2sec)     ! time [units = days]
          endif                                  ! into
          if (tauM2_out > 0.) then               ! nudging coefficient
            tauM2_out=1./(tauM2_out*day2sec)     ! [units = 1/sec]
          endif
# ifdef SOLVE3D
          if (tauM3_in > 0.) then
            tauM3_in =1./(tauM3_in *day2sec)
          endif
          if (tauM3_out > 0.) then
            tauM3_out=1./(tauM3_out*day2sec)
          endif
          if (tauT_in > 0.) then
            tauT_in =1./(tauT_in *day2sec)
          endif
          if (tauT_out > 0.) then
            tauT_out=1./(tauT_out*day2sec)
          endif
# endif
          mpi_master_only write(*,'(6x,A,ES10.3,ES10.3,2A)')
     &          'tauM2 =', tauM2_in, tauM2_out, '(in/out)  Nudging ',
     &                                   'for barotropic mode [s^-1]'
          mpi_master_only write(*,'(5x,A,ES10.3,2x,2A)') 'attnM2 =',
     &    attnM2,'open boundary pressure-gradient attenuation [s^-1]'
# ifdef SOLVE3D
          mpi_master_only write(*,'(6x,A,ES10.3,ES10.3,2A)')
     &          'tauM3 =', tauM3_in, tauM3_out, '(in/out)  Nudging ',
     &                                   'for baroclinic mode [s^-1]'
          mpi_master_only write(*,'(7x,A,ES10.3,ES10.3,2A)')
     &             'tauT =', tauT_in, tauT_out, '(in/out)  Nudging ',
     &                                          'for tracers [s^-1]'
# endif
           <--- OBSOLETE */
#endif


#ifdef SPONGE
! Parameters for the sponge layers

#  ifdef SPONGE_WIDTH
         elseif (keyword(1:kwlen).eq.'sponge') then
           call cancel_kwd (keyword(1:kwlen), ierr)
           read(input,*,err=95) n_sponge,v_sponge
           MPI_master_only write(*,'(1pe10.2,2x,A)') n_sponge
     &       ,'n_sponge Number of grid lines in sponge layer [-]'
#  else
        elseif (keyword(1:kwlen) == 'v_sponge') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) v_sponge
#  endif
          mpi_master_only write(*,'(3x,A,F10.2,2x,A)') 'v_sponge =',
     &        v_sponge, 'maximum viscosity in sponge layer [m^2/s]'
#endif
#ifdef OBC_FLUX_CORR
        elseif (keyword(1:kwlen) == 'tau_obc') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) tau_obc
          mpi_master_only write(*,'(1x,A,ES10.3,2x,2A)')
     &      'tau_obc =',  tau_obc, 'OBC volume constraint ',
     &                           'relaxation period [days]'
          tau_obc=tau_obc*day2sec
#endif

! Input file controls:  grid, initial conditions, surface forcing,
!----- ----- ---------  climatology, lateral boundary forcing data

#ifndef ANA_GRID
! Grid file name. Check its availability.

        elseif (keyword(1:kwlen) == 'grid') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES && !defined JOINED_GRD
          call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
          open(testunit,file=fname(1:lstr), status='old', err=97)
          close(testunit)
          grdname=fname(1:lstr)
          mpi_master_only write(*,'(1x,2A)') 'grid file: ',
     &                                     grdname(1:lstr)
#endif

! Initial conditions file name. Check its availability (in the case
! of analytical initial conditions and nrrec=0 initial conditions are
! created internally and no file is needed).

        elseif (keyword(1:kwlen) == 'initial') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) nrrec
#ifdef ANA_INITIAL
          if (nrrec > 0) then
#endif
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
#if defined MPI && defined PARALLEL_FILES
            call insert_node(fname, lstr, mynode, NNODES, ierr)
#endif
            ininame=fname(1:lstr)
            mpi_master_only write(*,'(1x,A,I3,2x,3A)')
     &       'initial condition :: rec =', nrrec,  'file = ''',
     &                                   ininame(1:lstr), ''''
#ifdef ANA_INITIAL
          endif
#endif
#if !defined ANA_SMFLUX  ||  defined SOLVE3D  &&\
   ( !defined ANA_STFLUX  ||\
     (defined SG_BBL96    && !defined ANA_BSEDIM) ||\
     (defined SG_BBL96    && !defined ANA_WWAVE)  ||\
     (defined QCORRECTION && !defined ANA_SST)    ||\
     (defined SALINITY    && !defined ANA_SSFLUX) ||\
     (defined LMD_KPP     && !defined ANA_SRFLUX))


! Forcing file name. Check its availability.

        elseif (keyword(1:kwlen) == 'forcing') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          max_frc=0
          lstr=1
          do while(lstr > 0 .and. max_frc < max_frc_files+1)
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
            if (lstr > 0) then
# if defined MPI && defined PARALLEL_FILES
              call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
              open(testunit,file=fname(1:lstr),status='old',err=97)
              close(testunit)

              if (max_frc < max_frc_files) then
                max_frc=max_frc+1
                frcfile(max_frc)=fname(1:lstr)
# ifdef MPI_SILENT_MODE
                if (mynode == 0) then
# endif
                  if (max_frc == 1) then
                    write(*,'(1x,2A)') 'forcing data file(s): ',
     &                                 frcfile(max_frc)(1:lstr)
                  else
                    write(*,'(23x,A)') frcfile(max_frc)(1:lstr)
                  endif

# ifdef MPI_SILENT_MODE
                endif
# endif
              else
                mpi_master_only write(*,'(1x,2A/12x,2A/)')
     &          '### ERROR: read_inp :: Too many forcing files are ',
     &          'specified in input script.',  'Increase parameter ',
     &                '''max_frc_files'' in ncvars.h and recompile.'
                ierr=ierr+1
              endif
            endif
          enddo
#endif

! Boundary forcing data file names. Check availability.

#if defined T_FRC_BRY || defined M2_FRC_BRY || defined M3_FRC_BRY \
                      || defined Z_FRC_BRY  || defined WKB_FRC_BRY
# ifndef ANA_BRY

        elseif (keyword(1:kwlen) == 'boundary') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          max_bry=0
          lstr=1
          do while(lstr > 0 .and. max_bry < max_bry_files+1)
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
            if (lstr > 0) then
#  if defined MPI && defined PARALLEL_FILES
              call insert_node(fname, lstr, mynode, NNODES, ierr)
#  endif
              open(testunit, file=fname(1:lstr), status='old',err=97)
              close(testunit)

              if (max_bry < max_bry_files) then
                max_bry=max_bry+1
                bry_file(max_bry)=fname(1:lstr)
#  ifdef MPI_SILENT_MODE
                if (mynode == 0) then
#  endif
                  if (max_bry == 1) then
                    write(*,'(1x,2A)') 'boundary forcing file(s): ',
     &                                  bry_file(max_bry)(1:lstr)
                  else
                    write(*,'(27x,A)')  bry_file(max_bry)(1:lstr)

                  endif
#  ifdef MPI_SILENT_MODE
                endif
#  endif
              else
                mpi_master_only write(*,'(1x,2A/12x,2A/)')
     &         '### ERROR: read_inp :: Too many boundary files are ',
     &         'specified in input script.',   'Increase parameter ',
     &                '''max_bry_files'' in ncvars.h and recompile.'
                ierr=ierr+1
              endif
            endif
          enddo
# endif
#endif

! Climatology file name. Climatology data is needed for (1) to supply
! boundary data for T,S,u,v at open boundaries (just one row of points)
! and (2) nudging to T,S data inside the domain within the  nudging
! finite-width band near the boundary [although depreciated,  this
! practice  remains in some applications; doing so for u,v is no
! longer supported by this code].  Aternatively to (1), the boundary
! data may also be supplied via BRY mechanism, where file contains
! perimeter data only.  In this case (activated by T_FRC_BRY), no
! climatology file is needed.  The following code segments also
! checks for availability of clm_files.

#if defined BGC_RESTORE && !defined ANA_TCLIMA || defined SOLVE3D && \
   ( defined TCLIMATOLOGY || ( defined TNUDGING && defined T_FRC_BRY )) 

        elseif (keyword(1:kwlen) == 'climatology') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          max_clm=0
          lstr=1
            do while (lstr > 0 .and. max_clm < max_clm_files+1)
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
            if (lstr > 0) then
# if defined MPI && defined PARALLEL_FILES
          call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
              open(testunit, file=fname(1:lstr), status='old', err=97)
              close(testunit)
              if (max_clm < max_frc_files) then
                max_clm=max_clm+1
                clm_file(max_clm)=fname(1:lstr)
# ifdef MPI_SILENT_MODE
                if (mynode == 0) then
# endif
                  if (max_clm == 1) then
                    write(*,'(1x,2A)') 'climatology data file(s): ',
     &                                 clm_file(max_clm)(1:lstr)
                  else
                    write(*,'(23x,A)') clm_file(max_clm)(1:lstr)
                  endif

# ifdef MPI_SILENT_MODE
                endif
# endif
              else
                mpi_master_only write(*,'(1x,2A/12x,2A/)')
     &          '### ERROR: read_inp :: Too many climatology files are ',
     &          'specified in input script.',  'Increase parameter ',
     &                '''max_clm_files'' in ncvars.h and recompile.'
                ierr=ierr+1
              endif
            endif
          enddo
#endif

! Output files controls: restart, history, averages, stations, floats
!------- ----- ---------

        elseif (keyword(1:kwlen) == 'restart') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) nrst, nrpfrst
          read(input,'(A)',err=95)  fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES && !defined JOINED_RST
          call insert_node(fname, lstr, mynode, NNODES, ierr)
#endif
          rstname=fname(1:lstr)
          mpi_master_only write(*,'(1x,A,I8, 2x,A,I5, 2x,3A)')
     &          'restart :: nrst =',nrst, 'rec/file =', nrpfrst,
     &                        'file =''', rstname(1:lstr), ''''
#ifndef SOLVE3D
          nrst=nrst*ndtfast
#endif

! history file controls: owerwrite flag, output frequency, number
! of reconds per file in sequence, and filename

        elseif (keyword(1:kwlen) == 'history') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) ldefhis, nwrt, nrpfhis
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#if defined MPI && defined PARALLEL_FILES && !defined JOINED_HIS
          call insert_node(fname, lstr, mynode, NNODES, ierr)
#endif
          hisname=fname(1:lstr)
          mpi_master_only write(*,'(/1x,A,L1,2x,A,I5,2x,A,I4,2x,3A)')
     &       'history :: overwrite = ', ldefhis,      'nwrt =', nwrt,
     &       'rec/file =', nrpfhis, 'file = ''',hisname(1:lstr),''''
#ifndef SOLVE3D
          nwrt=nwrt*ndtfast
#endif

! Which fields to be saved into history file.

        elseif (keyword(1:kwlen) == 'primary_history_fields') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) wrthis(indxZ),  wrthis(indxUb)
     &                                      ,  wrthis(indxVb)
#ifdef SOLVE3D
     &                      ,  wrthis(indxU),  wrthis(indxV)
     &                      , (wrthis(indxT+itrc-1), itrc=1,NT)
# ifdef SEDIMENT_BIOLOGY
     &                      , (wrthis(itrc), 
     &                         itrc=indxSedOrgN,indxSedOrgN+NT_sed-1)
# endif /* SEDIMENT_BIOLOGY */
#endif
      if (any(wrthis)) wrthis(indxTime)=.true.


      BEGIN_MPI_MASTER
!      write(*,*) 'fields to write into history file:'
      nbasic=3 ! zeta, ubar, vbar
      END_MPI_MASTER
#ifdef SOLVE3D
      BEGIN_MPI_MASTER
      write(*,*)
      nbasic=nbasic+2 ! u, v
      call echo_to_write(wrthis(indxZ), nbasic,'primary'
     &         , 'history',vname(1,indxZ))
      call echo_to_write(wrthis(indxT), NT,'tracer'
     &         , 'history',vname(1,indxT))
# ifdef SEDIMENT_BIOLOGY
      call echo_to_write(wrthis(indxSedOrgN), NT_sed,'sediment'
     &         , 'history',vname(1,indxSedOrgN))
# endif /* SEDIMENT_BIOLOGY */
      END_MPI_MASTER
        elseif (keyword(1:kwlen) == 'auxiliary_history_fields') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) wrthis(indxR), wrthis(indxO)
     &          ,  wrthis(indxW),  wrthis(indxAkv),  wrthis(indxAkt)
# ifdef SALINITY
     &                                            ,  wrthis(indxAks)
# endif
# ifdef LMD_KPP
     &                                            ,  wrthis(indxHbls)
# endif
# ifdef LMD_BKPP
     &                                           ,  wrthis(indxHbbl)
# endif
# if defined WRITE_HEATFLX
     &                                            ,  wrthis(indxHeatflx)
# endif
# if defined WRITE_TEMP_REST
     &                                            ,  wrthis(indxRestflxTemp)
# endif
# if defined WRITE_SALT_REST
     &                                            ,  wrthis(indxRestflxSalt)
# endif
# if defined  WRITE_CO2FLX
     &                                            ,  wrthis(indxCO2flx)
# endif

      BEGIN_MPI_MASTER
      naux=3 ! omega, w, rho
      call echo_to_write(wrthis(indxO), naux,'auxiliary'
     &         , 'history',vname(1,indxO))
      naux=2 ! Akv, Akt
# ifdef SALINITY
      naux=naux+1
# endif
# ifdef LMD_KPP
      naux=naux+1
# endif
# ifdef LMD_BKPP
      naux=naux+1
# endif
# if defined WRITE_HEATFLX
      naux=naux+1
# endif
# if defined WRITE_TEMP_REST
      naux=naux+1
# endif
# if defined WRITE_SALT_REST
      naux=naux+1
# endif
      call echo_to_write(wrthis(indxAkv), naux,'mixing'
     &         , 'history',vname(1,indxAkv))
      END_MPI_MASTER

#else /* SOLVE3D */
      mpi_master_only call echo_to_write(wrthis(indxT), nbasic,'f'
     &         , 'history',vname(1,indxSedOrgN))
#endif /* SOLVE3D */


#ifdef AVERAGES
! Averages controls: time step number to start averaging (sets phase
! for averaging windows); averaging interval in time steps; number of
! records per file, and output filename.

        elseif (keyword(1:kwlen) == 'averages') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) ntsavg, navg, nrpfavg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES && !defined JOINED_AVG
          call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
          avgname=fname(1:lstr)
          mpi_master_only write(*,'(/1x,A,I5,2x,A,I5,2x,A,I4,2x,3A)')
     &       'averages :: ntsavg = ', ntsavg,      'navg =', navg,
     &       'rec/file =', nrpfavg, 'file = ''', avgname(1:lstr), ''''
# ifndef SOLVE3D
          ntsavg=ntsavg*ndtfast ; navg=navg*ndtfast
# endif

! Switches for fields to compute averages.

        elseif (keyword(1:kwlen) == 'primary_averages') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtavg(indxZ),  wrtavg(indxUb)
     &                                        ,  wrtavg(indxVb)
# ifdef SOLVE3D
     &                      ,  wrtavg(indxU),     wrtavg(indxV)
     &                      , (wrtavg(indxT+itrc-1), itrc=1,NT)
# ifdef SEDIMENT_BIOLOGY
     &                      , (wrtavg(itrc), 
     &                         itrc=indxSedOrgN,indxSedOrgN+NT_sed-1)
# endif /* SEDIMENT_BIOLOGY */
# endif
      if (any(wrtavg)) wrtavg(indxTime)=.true.

      BEGIN_MPI_MASTER
!      write(*,*) 'fields to write into history file:'
      nbasic=3 ! zeta, ubar, vbar
# ifdef SOLVE3D
      nbasic=nbasic+2 ! u, v
# endif
      call echo_to_write(wrtavg(indxZ), nbasic,'primary'
     &         , 'averages',vname(1,indxZ))
      call echo_to_write(wrtavg(indxT), NT,'tracer'
     &         , 'averages',vname(1,indxT))
# ifdef SEDIMENT_BIOLOGY
      call echo_to_write(wrtavg(indxSedOrgN), NT_sed,'sediment'
     &         , 'averages',vname(1,indxSedOrgN))
# endif /* SEDIMENT_BIOLOGY */
      END_MPI_MASTER

        elseif (keyword(1:kwlen) == 'auxiliary_averages') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtavg(indxR), wrtavg(indxO)
     &          ,  wrtavg(indxW),  wrtavg(indxAkv),  wrtavg(indxAkt)
#  ifdef SALINITY
     &                                            ,  wrtavg(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                            ,  wrtavg(indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                                            ,  wrtavg(indxHbbl)
# endif
# ifdef KPP_DIAGNOSE
     &                                            ,  wrtavg(indxKppRichm)
     &                                            ,  wrtavg(indxKppRicht)
     &                                            ,  wrtavg(indxKppSblSh)
     &                                            ,  wrtavg(indxKppSblSt)
     &                                            ,  wrtavg(indxKppSblRot)
     &                                            ,  wrtavg(indxKppSblEnt)
# endif
# if defined WRITE_HEATFLX
     &                                            ,  wrtavg(indxHeatflx)
# endif
# if defined WRITE_TEMP_REST
     &                                            ,  wrtavg(indxRestflxTemp)
# endif
# if defined WRITE_SALT_REST
     &                                            ,  wrtavg(indxRestflxSalt)
# endif
      BEGIN_MPI_MASTER
      naux=3 ! omega, w, rho
      call echo_to_write(wrtavg(indxO), naux,'auxiliary'
     &         , 'averages',vname(1,indxO))
      naux=2 ! Akv, Akt
# ifdef SALINITY
      naux=naux+1
# endif
# ifdef LMD_KPP
      naux=naux+1
# endif
# ifdef LMD_BKPP
      naux=naux+1
# endif
# ifdef KPP_DIAGNOSE
      naux=naux+6
# endif
# if defined WRITE_HEATFLX
      naux=naux+1
# endif
# if defined WRITE_TEMP_REST
      naux=naux+1
# endif
# if defined WRITE_SALT_REST
      naux=naux+1
# endif
      call echo_to_write(wrtavg(indxAkv), naux,'mixing'
     &         , 'averages',vname(1,indxAkv))
      END_MPI_MASTER

# ifdef SLICE_AVG
! Averages controls: slice level (ksl),time step number to start averaging (sets phase
! for averaging windows); averaging interval in time steps; number of
! records per file, and output filename.

        elseif (keyword(1:kwlen) == 'slice_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) ksl, ntsslavg, nslavg, nrpfslavg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES && !defined JOINED_AVG
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
          slavgname=fname(1:lstr)
          mpi_master_only write(*,'(/1x,A,i3,A,I5,2x,A,I5,2x,A,I4,2x,3A)')
     &       'slice averages :: level = ',ksl, ', ntsslavg = ', ntsslavg
     &       ,  'nslavg =', nslavg,
     &       'rec/file =', nrpfslavg, 'file = ''', slavgname(1:lstr), ''''

! Switches for fields to compute slice averages.

        elseif (keyword(1:kwlen) == 'primary_slice_avg') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtslavg(indxZ),  wrtslavg(indxUb)
     &                                        ,  wrtslavg(indxVb)
#  ifdef SOLVE3D
     &                      ,  wrtslavg(indxU),     wrtslavg(indxV)
     &                      , (wrtslavg(indxT+itrc-1), itrc=1,NT)
#  endif
      if (any(wrtslavg)) wrtslavg(indxTime)=.true.

      BEGIN_MPI_MASTER
!      write(*,*) 'fields to write into history file:'
      nbasic=3 ! zeta, ubar, vbar
#  ifdef SOLVE3D
      nbasic=nbasic+2 ! u, v
#  endif
      call echo_to_write(wrthis(indxZ), nbasic,'primary'
     &         , 'slice averages',vname(1,indxZ))
      call echo_to_write(wrthis(indxT), NT,'tracer'
     &         , 'slice averages',vname(1,indxT))
#  ifdef SEDIMENT_BIOLOGY
      call echo_to_write(wrthis(indxSedOrgN), NT_sed,'sediment'
     &         , 'slice averages',vname(1,indxSedOrgN))
#  endif /* SEDIMENT_BIOLOGY */
      END_MPI_MASTER

        elseif (keyword(1:kwlen) == 'auxiliary_slice_avg') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtslavg(indxR), wrtslavg(indxO)
     &       ,  wrtslavg(indxW),  wrtslavg(indxAkv),  wrtslavg(indxAkt)
#  ifdef SALINITY
     &                                            ,  wrtslavg(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                            ,  wrtslavg(indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                                            ,  wrtslavg(indxHbbl)
#  endif
      BEGIN_MPI_MASTER
      naux=3 ! omega, w, rho
      call echo_to_write(wrtslavg(indxO), naux,'auxiliary'
     &         , 'slice-averages',vname(1,indxO))
      naux=2 ! Akv, Akt
#  ifdef SALINITY
      naux=naux+1
#  endif
#  ifdef LMD_KPP
      naux=naux+1
#  endif
#  ifdef LMD_BKPP
      naux=naux+1
#  endif
      call echo_to_write(wrtslavg(indxAkv), naux,'mixing'
     &         , 'slice averages',vname(1,indxAkv))
      END_MPI_MASTER
# endif /* SLICE_AVG */

# ifdef OBSOLETE_PIECE
#  ifdef SLICE_AVG
        elseif (keyword(1:kwlen) == 'slice_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) ksl, ntsslavg, nslavg, nrpfslavg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#   if defined MPI && defined PARALLEL_FILES && !defined JOINED_AVG
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#   endif
          slavgname=fname(1:lstr)
          mpi_master_only write(*,'(/1x,A,I5,2x,A,I5,2x,A,I4,2x,3A)')
     &       'averages :: ntsslavg = ', ntsslavg,      'nslavg =', nslavg,
     &       'rec/file =', nrpfslavg, 'file = ''', slavgname(1:lstr), ''''

! Switches for fields to compute averages.

        elseif (keyword(1:kwlen) == 'primary_slice_avg') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtslavg(indxZ),  wrtslavg(indxUb)
     &                                        ,  wrtslavg(indxVb)
     &                      ,  wrtslavg(indxU),     wrtslavg(indxV)
     &                      , (wrtslavg(indxT+itrc-1), itrc=1,NT)
          if ( wrtslavg(indxZ) .or. wrtslavg(indxUb) .or. wrtslavg(indxVb)
     &                       .or. wrtslavg(indxU)  .or. wrtslavg(indxV)
     &       ) wrtslavg(indxTime)=.true.

          mpi_master_only write(*,'(/1x,A,5(/8x,A,T16,L1,T20,A))')
     &                   'fields to compute slice averages of: (T/F)'
     &                 , 'zeta',   wrtslavg(indxZ),    vname(2,indxZ)
     &                 , 'ubar',   wrtslavg(indxUb),   vname(2,indxUb)
     &                 , 'vbar',   wrtslavg(indxVb),   vname(2,indxVb)
     &                 , 'u',      wrtslavg(indxU),    vname(2,indxU)
     &                 , 'v',      wrtslavg(indxV),    vname(2,indxV)
          do itrc=1,NT
            if (wrtslavg(indxT+itrc-1)) wrtslavg(indxTime)=.true.
            mpi_master_only write(*,'(8x,A,I2,A,T16,L1,T20,A)') 't(',
     &        itrc, ')', wrtslavg(indxT+itrc-1), vname(2,indxT+itrc-1)
          enddo
#   ifdef SEDIMENT_BIOLOGY
          do itrc = 1, NT_sed
            if (wrtslavg(indxSedOrgN+itrc-1)) wrtslavg(indxTime)=.true.
            MPI_master_only write(*, '(6x,L1,2x,A,I2,A,I2,A)')
     &           wrtslavg(indxSedOrgN+itrc-1), 'write T_sed(', 
     &           itrc,')  Sediment tracer of index ', itrc,'.' 
          end do
#   endif /* SEDIMENT_BIOLOGY */

        elseif (keyword(1:kwlen) == 'auxiliary_slice_avg') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtslavg(indxR), wrtslavg(indxO)
     &          ,  wrtslavg(indxW),  wrtslavg(indxAkv),  wrtslavg(indxAkt)
#   ifdef SALINITY
     &                                            ,  wrtslavg(indxAks)
#   endif
#   ifdef LMD_KPP
     &                                            ,  wrtslavg(indxHbls)
#   endif
#   ifdef LMD_BKPP
     &                                            ,  wrtslavg(indxHbbl)
#   endif
          if ( wrtslavg(indxR) .or. wrtslavg(indxO) .or. wrtslavg(indxW)
     &                     .or. wrtslavg(indxAkv) .or. wrtslavg(indxAkt)
#   ifdef SALINITY
     &                                          .or. wrtslavg(indxAks)
#   endif
#   ifdef LMD_KPP
     &                                          .or. wrtslavg(indxHbls)
#   endif
#   ifdef LMD_BKPP
     &                                          .or. wrtslavg(indxHbbl)
#   endif
     &       ) wrtslavg(indxTime)=.true.

          mpi_master_only write(*,'(8(/8x,A,T16,L1,T20,A))')
     &                   'rho',    wrtslavg(indxR),    vname(2,indxR)
     &                 , 'Omega',  wrtslavg(indxO),    vname(2,indxO)
     &                 , 'W',      wrtslavg(indxW),    vname(2,indxW)
     &                 , 'Akv',    wrtslavg(indxAkv),  vname(2,indxAkv)
     &                 , 'Akt',    wrtslavg(indxAkt),  vname(2,indxAkt)
#   ifdef SALINITY
     &                 , 'Aks',    wrtslavg(indxAks),  vname(2,indxAks)
#   endif
#   ifdef LMD_KPP
     &                 , 'hbls',   wrtslavg(indxHbls), vname(2,indxHbls)
#    endif
#   ifdef LMD_BKPP
     &                 , 'hbbl',   wrtslavg(indxHbbl), vname(2,indxHbbl)
#   endif
#  endif /* SLICE_AVERAGES */
# endif /* OBSOLETE_PIECE */
#endif /* AVERAGES */

#ifdef BGC_FLUX_ANALYSIS
!
! File name for histories of biogeochemical fluxes
!
        elseif (keyword(1:kwlen).eq.'bgc_flux_histories') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_bgc_flux_his,
     &         n_bgc_flux_his, nrpf_bgc_flux_his
          read(input,'(A)',err=95) fname
#  ifdef SCRATCH_DIR
          fname=trim(scr_dir)/ /trim(fname)
#  endif
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES && !defined JOINED_BGC_FLUX_HIS
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          bgc_flux_his_name=fname(1:lstr)
          MPI_master_only write(*,
     &           '(I10,2x,A,1x,A/32x,A/,6x,A,2x,A,1x,A,I3)')
     &      n_bgc_flux_his,   
     &         'n_bgc_flux_his     Number of timesteps between',
     &     'writing of',
     &         ' biogeochemical fluxes into file.',
     &     'Biogeochemical flux file:', 
     &         bgc_flux_his_name(1:lstr),
     &     'rec/file =', nrpf_bgc_flux_his

# ifdef AVERAGES
!
! File name for averages of biogeochemical fluxes
!
        elseif (keyword(1:kwlen).eq.'bgc_flux_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_bgc_flux_avg,
     &         nts_bgc_flux_avg, n_bgc_flux_avg, nrpf_bgc_flux_avg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES && !defined JOINED_BGC_FLUX_AVG
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
          bgc_flux_avg_name=fname(1:lstr)
          MPI_master_only write(*,
     &           '(2(I10,2x,A,1x,A/32x,A/),6x,A,2x,A,1x,A,I3)')
     &      nts_bgc_flux_avg, 
     &         'nts_bgc_flux_avg   Starting timestep for the',
     &           ' accumulation of output', 
     &         ' time-averaged biogeochemical fluxes.',
     &      n_bgc_flux_avg,   
     &         'n_bgc_flux_avg     Number of timesteps between',
     &     'writing of',
     &         ' time-averaged biogeochemical fluxes into file.',
     &     'Averaged biogeochemical flux file:', 
     &         bgc_flux_avg_name(1:lstr),
     &     'rec/file =', nrpf_bgc_flux_avg
# endif /* AVERAGES */
#endif /* BGC_FLUX_ANALYSIS */
#ifdef PHYS_FLUX_ANALYSIS
!
! File name for histories of physical fluxes
!
        elseif (keyword(1:kwlen).eq.'phys_flux_histories') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_phys_flux_his,
     &         n_phys_flux_his, nrpf_phys_flux_his
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES && !defined PHYS_FLUX_HIS
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          phys_flux_his_name=fname(1:lstr)
          MPI_master_only write(*,
     &           '(I10,2x,A,1x,A/32x,A/,6x,A,2x,A,1x,A,I3)')
     &      n_phys_flux_his,
     &         'n_phys_flux_his    Number of timesteps between',
     &     ' writing of',
     &         ' physical fluxes into file.',
     &     'Physical flux file:',
     &         phys_flux_his_name(1:lstr),
     &     'rec/file =', nrpf_phys_flux_his

# ifdef AVERAGES
!
! File name for averages of physical fluxes
!
        elseif (keyword(1:kwlen).eq.'phys_flux_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_phys_flux_avg,
     &         nts_phys_flux_avg, n_phys_flux_avg,
     &         nrpf_phys_flux_avg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES && !defined PHYS_FLUX_AVG
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
          phys_flux_avg_name=fname(1:lstr)
          MPI_master_only write(*,
     &           '(2(I10,2x,A,1x,A/32x,A/),6x,A,2x,A,1x,A,I3)')
     &      nts_phys_flux_avg,
     &         'nts_phys_flux_avg  Starting timestep for the',
     &           ' accumulation of output',
     &         ' time-averaged physical fluxes.',
     &      n_phys_flux_avg,
     &         'n_phys_flux_avg    Number of timesteps between',
     &     ' writing of',
     &         ' time-averaged physical fluxes into file.',
     &     'Averaged physical flux file:',
     &         phys_flux_avg_name(1:lstr),
     &     'rec/file =', nrpf_phys_flux_avg
# endif /* AVERAGES */
#endif /* PHYS_FLUX_ANALYSIS */

#ifdef STATIONS
! Stations control: file with station locations; output
! interval and number of records per file; output filename:

        elseif (keyword(1:kwlen) == 'stations') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) nsta, nrpfstn
          read(input,'(A)',err=95) fname
          read(input,'(A)',err=95) staname
          lstr=lenstr(fname)

          mpi_master_only write(*,'(1x,A,I5,2x,A,I4,2x,3A/13x,3A)')
     &            'stations :: nsta =', nsta,  'rec/file =', nrpfstn,
     &            'positions file = ''', fname(1:lstr), '''',
     &            'output file = ''', staname(1:lenstr(staname)), ''''

          call read_sta_pos (fname,ierr)

! Switches for fields to sample into stations file:

        elseif (keyword(1:kwlen) == 'primary_stations') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtsta(indxZ),  wrtsta(indxUb)
     &                                         , wrtsta(indxVb)
# ifdef SOLVE3D
     &                      ,  wrtsta(indxU),     wrtsta(indxV)
     &                      , (wrtsta(indxT+itrc-1), itrc=1,NT)
# endif
          if ( wrtsta(indxZ) .or. wrtsta(indxUb) .or. wrtsta(indxVb)
# ifdef SOLVE3D
     &                       .or. wrtsta(indxU)  .or. wrtsta(indxV)
# endif
     &       ) wrtsta(indxTime)=.true.

          mpi_master_only write(*,'(/1x,A,5(/8x,A,T16,L1,T20,A))')
     &                   'fields to sample into stations file: (T/F)'
     &                 , 'zeta',   wrtsta(indxZ),    vname(2,indxZ)
     &                 , 'ubar',   wrtsta(indxUb),   vname(2,indxUb)
     &                 , 'vbar',   wrtsta(indxVb),   vname(2,indxVb)
# ifdef SOLVE3D
     &                 , 'u',      wrtsta(indxU),    vname(2,indxU)
     &                 , 'v',      wrtsta(indxV),    vname(2,indxV)
          do itrc=1,NT
            if (wrtsta(indxT+itrc-1)) wrtsta(indxTime)=.true.
            mpi_master_only write(*,'(8x,A,I2,A,T16,L1,T20,A)') 't(',
     &        itrc, ')', wrtsta(indxT+itrc-1), vname(2,indxT+itrc-1)
          enddo

        elseif (keyword(1:kwlen) == 'auxiliary_stations') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtsta(indxR), wrtsta(indxO)
     &          ,  wrtsta(indxW),  wrtsta(indxAkv),  wrtsta(indxAkt)
#  ifdef SALINITY
     &                                            ,  wrtsta(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                            ,  wrtsta(indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                                            ,  wrtsta(indxHbbl)
#  endif
          if ( wrtsta(indxR) .or. wrtsta(indxO) .or. wrtsta(indxW)
     &                     .or. wrtsta(indxAkv) .or. wrtsta(indxAkt)
#  ifdef SALINITY
     &                                          .or. wrtsta(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                          .or. wrtsta(indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                                          .or. wrtsta(indxHbbl)
#  endif
     &       ) wrtsta(indxTime)=.true.

          mpi_master_only write(*,'(8(/8x,A,T16,L1,T20,A))')
     &                   'rho',    wrtsta(indxR),    vname(2,indxR)
     &                 , 'Omega',  wrtsta(indxO),    vname(2,indxO)
     &                 , 'W',      wrtsta(indxW),    vname(2,indxW)
     &                 , 'Akv',    wrtsta(indxAkv),  vname(2,indxAkv)
     &                 , 'Akt',    wrtsta(indxAkt),  vname(2,indxAkt)
#  ifdef SALINITY
     &                 , 'Aks',    wrtsta(indxAks),  vname(2,indxAks)
#  endif
#  ifdef LMD_KPP
     &                 , 'hbls',   wrtsta(indxHbls), vname(2,indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                 , 'hbbl',   wrtsta(indxHbbl), vname(2,indxHbbl)
#  endif
# endif /* SOLVE3D */
#endif /* STATIONS */

!DL: keywords related to interannual variations of atm. pCO2:
#if (defined BIOLOGY_BEC || defined BIOLOGY_BEC2 || defined BIOLOGY_NPZDOC)\
    && defined VARIABLE_ANN_ATM_PCO2
        elseif (keyword(1:kwlen) == 'start_year') then
          ! Year at which the simulation starts. This is needed for
          ! the computation of the atmospheric pCO2. It can be a 
          ! floating point number, e.g. 2002.5 if the run starts in
          ! the middle of 2002.
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) start_year
          MPI_master_only write(*,'(1pe10.3,2x,A,1x,A)')
     &       start_year, 'start_year   point in time (year) when',
     &       'simulation starts'
#endif /* BIOLOGY_BEC || BIOLOGY_BEC2 || BIOLOGY_NPZDOC) && VARIABLE_ANN_ATM_PCO2 */





#ifdef FLOATS
! Floats file name.

      elseif (keyword(1:kwlen) == 'floats') then
        call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) ldefflt, nflt, nrpfflt
          read(input,'(A)',err=95) fposnam
          read(input,'(A)',err=95) fltname
# if defined MPI && defined PARALLEL_FILES
          call insert_node(fposname, lstr, mynode, NNODES, ierr)
# endif
          lstr=lenstr(fltname)
          mpi_master_only write(*,'(/1x,A,L1,2x,A,I5,2x,A,I4,2x,3A)')
     &       'floats :: overwrite = ', ldefflt,      'nflt =', nflt,
     &       'rec/file =', nrpfflt, 'file = ''', fltname(1:lstr), ''''

! Switches for fields to be saved into floats output file.

      elseif (keyword(1:kwlen)=='float_fields') then
        call cancel_kwd(keyword(1:kwlen), ierr)
# ifdef AGRIF
        if (Agrif_Root()) then
# endif
          read(input,*,err=95) wrtflt(indxfltGrd),
     &       wrtflt(indxfltTemp), wrtflt(indxfltSalt),
     &       wrtflt(indxfltRho),  wrtflt(indxfltVel)
          mpi_master_only write(*,'(/1x,A,5(/6x,l1,2x,A))')
     &      'fields to be saved in floats output  (T/F)'
     &     , wrtflt(indxfltGrd),   'write Grid location variables'
     &     , wrtflt(indxfltTemp),  'write temperature.'
     &     , wrtflt(indxfltSalt),  'write salinity.'
     &     , wrtflt(indxfltRho),   'write density.'
     &     , wrtflt(indxfltVel),   'write mean float velocity'
# ifdef AGRIF
        endif
# endif
#endif /* FLOATS */



#ifdef MOORE_BEC
        elseif (keyword(1:kwlen)=='mgm_history') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) nwrtmgm,  nprfmgm
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
          mgmfname=fname(1:lstr)
          mpi_master_only write(*,'(7x,A,2x,A,2x,A,2x,A,I42x,A,I3)')
     &         'MGM History File:', mgmfname(1:lstr),  'Create new:',
     &          'nwrt =', nwrtmgm, 'rec/file =', nprfmgm


        elseif (keyword(1:kwlen)=='mgm_avg') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) nwrtmgmavg,  nprfmgmavg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
          mgmavgfname=fname(1:lstr)
          mpi_master_only write(*,'(7x,A,2x,A,2x,A,2x,A,I42x,A,I3)')
     &        'MGM History File:', mgmavgfname(1:lstr),  'Create new:',
     &        'nwrt =', nwrtmgmavg, 'rec/file =', nprfmgmavg
#endif   /* MOORE_BEC */

! AH: Read tracer source file name
#if defined TSOURCE
        elseif (keyword(1:kwlen).eq.'tracer_source') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
          open (testunit, file=fname(1:lstr), status='old', err=97)
          close(testunit)
          tsrc_file=fname(1:lstr)
          MPI_master_only write(*,'(6x,A,2x,A)')
     &          'Tracer Source File:', tsrc_file(1:lstr)
#endif


!DL: age/dye tracers:
#if defined PASSIVE_TRACER && defined AGE_DYE_TRACER
        elseif (keyword(1:kwlen).eq.'age_dye') then
           call cancel_kwd (keyword(1:kwlen), ierr)
           ! Read number of age/dye tracers:
           read(input,*,err=95) N_agedye
           if (N_agedye .gt. ntrc_pas) then
              MPI_master_only write(*,'(3a,i6)') 'ERROR: ',
     &        'too many age/dye tracers. Set parameter ntrc_pas ',
     &        'in param.h to a value >= ', N_agedye
              goto 95
           end if
           MPI_master_only write(*,'(6x,i2,A)')
     &          N_agedye, ' Number of age/dye tracers'
#endif /* PASSIVE_TRACER && AGE_DYE_TRACER */
        else
          mpi_master_only write(*,'(/1x,4A/)') 'WARNING: ',
     &                'Urecognized keyword ''', keyword(1:kwlen),
     &                                      ''' --> DISREGARDED.'
        endif
       if (keyword(1:kwlen) == end_signal) goto 99
      goto 1

! Error while reading input parameters.

  95  write(*,'(/1x,4A/)') '### ERROR: read_inp :: Cannot read ',
     &                       'entry ''', keyword(1:kwlen), '''.'
      ierr=ierr+1
      goto 99
  97  lstr=lenstr(fname)
      write(*,'(/1x,4A/)') '### ERROR: read_inp :: Cannot find ',
     &                     'input file ''', fname(1:lstr), '''.'
      ierr=ierr+1
  99  close (input)

! Check that all keywords were canceled, complain about the error,
! if some of them left.

      if (ierr == 0) call check_kwds (ierr)
      if (ierr /= 0) then
        write(*,'(/1x,2A,I3,1x,A/)') '### ERROR: read_inp :: ',
     &  'A total of', ierr, 'configuration errors discovered.'
       return
      endif
      call check_srcs
#ifdef MPI
      call MPI_Barrier (ocean_grid_comm, ierr)
#endif
      mpi_master_only print '(/3A)', '------------'
     &    , ' Finished reading input parameters ', '------------'
      end

      subroutine echo_to_write(wrtflag, NT, c, s, var)
      implicit none
      integer, intent(in) ::  NT
      logical, dimension(NT), intent(in) :: wrtflag ! wrthis,wrtavg,wrtslavg
      character(len=*), dimension(4,NT), intent(in) :: var ! vname 
      character(len=*), intent(in) :: c  ! field type primary, tracer, sediment, auxil.
      character(len=*), intent(in) :: s 
      integer itrc
      logical :: skipped
      skipped = .false.

      if (any(wrtflag(1:NT))) write(*,'(6x,4a)') 
     &         trim(c),'_',trim(s),' fields requested:'
    
      do itrc=1,NT
        if (wrtflag(itrc)) then
          write(*,'(8x,2A,I2,A,T16,A,T24,A)')
     &      c(1:1),'(', itrc, ')', var(1,itrc), var(2,itrc)
        else
          skipped=.true.
        endif
      enddo

      if (skipped) then
        write(*,'(5x,A)') '  not written:'
        do itrc=1,NT
          if (.not. wrtflag(itrc)) then
            write(*,'(8x,3A,I2,A,T18,A,T24,A)')
     &         '- ',c(1:1),'(', itrc, ')', var(1,itrc), var(2,itrc)
          endif
        enddo
      endif
      end

                                            ! Find place in the string
      subroutine cancel_kwd(keyword, ierr)  ! kwds(1:max_opt_size)
      implicit none                         ! which matches the input
#include "strings.h"
      character(len=*) keyword              ! keyword name and turn it
      integer ierr, is,i,ie, lenkw,lenstr   ! into blank. Complain
      lenkw=lenstr(keyword)                 ! about error if not found.
      is=1
      do while (is>0 .and. is<max_opt_size)
        do while (kwds(is:is)==' ' .and. is<max_opt_size)
          is=is+1
        enddo
        ie=is+1
        do while (kwds(ie:ie)/=' ' .and. ie<max_opt_size)
          ie=ie+1
        enddo
        if (lenkw==ie-is .and. kwds(is:ie-1)==keyword) then
c**       write(*,'(1x,A,1x,A)') 'Recognized: ', kwds(is:ie-1)
          do i=is,ie-1
            kwds(i:i)=' '
          enddo
          is=0         !--> to signal that keyword is found and
        else           !                      terminate the search
          is=ie        !--> skip to the next word in "kwds" string
        endif
      enddo
      if (is/=0) then
        write(*,'(/A)') '##### ERROR #####'
        write(*,'(2(1x,A,1x,A,1x,A/)/)') 'cancel_kwd:',
     &         'Can not cancel keyword:',  keyword(1:lenkw),
     &         'check input script for possible',
     &         'duplicated keywords.'
        write(*,'(A/)') '#################'
        ierr=ierr+1
      endif
      end

                                      ! Check that keyword string is
      subroutine check_kwds (ierr)    ! empty, and if it is not print
      implicit none                   ! out remaining keyword(s) as
#include "strings.h"
      integer ierr, is,ie             ! an error message and increase
      is=1                            ! error counter ierr.
      do while (is<max_opt_size)
        do while (kwds(is:is)==' ' .and. is<max_opt_size)
          is=is+1
        enddo
        if (is<max_opt_size) then
          ie=is+1
          do while (kwds(ie:ie)/=' ' .and. ie<max_opt_size)
            ie=ie+1
          enddo
          ierr=ierr+1
          write(*,'(/1x,A,1x,A/)') '### ERROR: keyword not found:',
     &                                               kwds(is:ie-1)
          is=ie
        endif
      enddo
      end


